From 34d0d724e6b95404953678c68acce6760221f0aa Mon Sep 17 00:00:00 2001
From: root <root@localhost.arpa>
Date: Sun, 10 Mar 2024 15:16:39 +0100
Subject: [PATCH 03/28] cpufreq: sun50i: Add H616 support

AllWinner H616 SoC has few revisions that support different list
of uV and frequencies.

Some revisions have the same NVMEM value and thus we have to check
the SoC revision from SMCCC to differentiate between them.

Signed-off-by: Martin Botka <martin.botka@somainline.org>
---
 drivers/cpufreq/sun50i-cpufreq-nvmem.c | 130 +++++++++++++++++++------
 1 file changed, 99 insertions(+), 31 deletions(-)

diff --git a/drivers/cpufreq/sun50i-cpufreq-nvmem.c b/drivers/cpufreq/sun50i-cpufreq-nvmem.c
index 51d7010c49a7..96c3263f0c04 100644
--- a/drivers/cpufreq/sun50i-cpufreq-nvmem.c
+++ b/drivers/cpufreq/sun50i-cpufreq-nvmem.c
@@ -13,6 +13,7 @@
 
 #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
 
+#include <linux/arm-smccc.h>
 #include <linux/cpu.h>
 #include <linux/module.h>
 #include <linux/nvmem-consumer.h>
@@ -29,56 +30,97 @@
 #define SUN50I_H6_NVMEM_SHIFT 5
 
 struct sunxi_cpufreq_soc_data {
-	u32 (*efuse_xlate) (void *efuse);
+	int (*efuse_xlate)(u32 *versions, u32 *efuse, char *name, size_t len);
+	u8 ver_freq_limit;
 };
 
 static struct platform_device *cpufreq_dt_pdev, *sun50i_cpufreq_pdev;
 
-static u32 sun50i_h616_efuse_xlate(void *efuse)
+static int sun50i_h616_efuse_xlate(u32 *versions, u32 *efuse, char *name, size_t len)
 {
-   u32 efuse_value = (*(u32 *)efuse >> SUN50I_H616_NVMEM_SHIFT) &
-             SUN50I_H616_NVMEM_MASK;
+	int value = 0;
+	u32 speedgrade = 0;
+	u32 i;
+	int ver_bits = arm_smccc_get_soc_id_revision();
 
-   /* Tested as V1 h616 soc. Expected efuse values are 1 - 3,
-      slowest to fastest */
-   if (efuse_value >=1 && efuse_value <= 3)
-       return efuse_value - 1;
-   else
-       return 0;
-};
+	if (len > 4) {
+		pr_err("Invalid nvmem cell length\n");
+		return -EINVAL;
+	}
 
-static u32 sun50i_h6_efuse_xlate(void *efuse)
+	for (i = 0; i < len; i++)
+		speedgrade |= (efuse[i] << (i * 8));
+
+	switch (speedgrade) {
+	case 0x2000:
+		value = 0;
+		break;
+	case 0x2400:
+	case 0x7400:
+	case 0x2c00:
+	case 0x7c00:
+		if (ver_bits <= 1) {
+			/* ic version A/B */
+			value = 1;
+		} else {
+			/* ic version C and later version */
+			value = 2;
+		}
+		break;
+	case 0x5000:
+	case 0x5400:
+	case 0x6000:
+		value = 3;
+		break;
+	case 0x5c00:
+		value = 4;
+		break;
+	case 0x5d00:
+	default:
+		value = 0;
+	}
+	*versions = (1 << value);
+	snprintf(name, MAX_NAME_LEN, "speed%d", value);
+	return 0;
+}
+
+static int sun50i_h6_efuse_xlate(u32 *versions, u32 *efuse, char *name, size_t len)
 {
    u32 efuse_value = (*(u32 *)efuse >> SUN50I_H6_NVMEM_SHIFT) &
              SUN50I_H6_NVMEM_MASK;
 
    /*
     * We treat unexpected efuse values as if the SoC was from
-    * the slowest bin. Expected efuse values are 1 - 3, slowest
+    * the slowest bin. Expected efuse values are 1-3, slowest
     * to fastest.
    */
    if (efuse_value >= 1 && efuse_value <= 3)
-       return efuse_value - 1;
+       *versions = efuse_value - 1;
    else
-       return 0;
-};
+       *versions = 0;
+
+   snprintf(name, MAX_NAME_LEN, "speed%d", *versions);
+   return 0;
+}
 
 
 /**
  * sun50i_cpufreq_get_efuse() - Determine speed grade from efuse value
- * @soc_data: pointer to sunxi_cpufreq_soc_data context
+ * @soc_data: Struct containing soc specific data & functions
  * @versions: Set to the value parsed from efuse
+ * @name: Set to the name of speed
  *
  * Returns 0 if success.
  */
 static int sun50i_cpufreq_get_efuse(const struct sunxi_cpufreq_soc_data *soc_data,
-		u32 *versions)
+		u32 *versions, char *name)
 {
 	struct nvmem_cell *speedbin_nvmem;
 	struct device_node *np;
 	struct device *cpu_dev;
 	u32 *speedbin;
 	size_t len;
+	int ret;
 
 	cpu_dev = get_cpu_device(0);
 	if (!cpu_dev)
@@ -87,9 +129,10 @@ static int sun50i_cpufreq_get_efuse(const struct sunxi_cpufreq_soc_data *soc_dat
 	np = dev_pm_opp_of_get_opp_desc_node(cpu_dev);
 	if (!np)
 		return -ENOENT;
-	if (of_device_is_compatible(np, "allwinner,sun50i-h6-operating-points")) {}
-	else if (of_device_is_compatible(np, "allwinner,sun50i-h616-operating-points")) {}
-	else {
+
+	if (of_device_is_compatible(np, "allwinner,sun50i-h6-operating-points")) {
+	} else if (of_device_is_compatible(np, "allwinner,sun50i-h616-operating-points")) {
+	} else {
 		of_node_put(np);
 		return -ENOENT;
 	}
@@ -105,7 +148,9 @@ static int sun50i_cpufreq_get_efuse(const struct sunxi_cpufreq_soc_data *soc_dat
 	if (IS_ERR(speedbin))
 		return PTR_ERR(speedbin);
 
-	*versions = soc_data->efuse_xlate(speedbin);
+	ret = soc_data->efuse_xlate(versions, speedbin, name, len);
+	if (ret)
+		return ret;
 
 	kfree(speedbin);
 	return 0;
@@ -114,30 +159,29 @@ static int sun50i_cpufreq_get_efuse(const struct sunxi_cpufreq_soc_data *soc_dat
 static int sun50i_cpufreq_nvmem_probe(struct platform_device *pdev)
 {
 	const struct of_device_id *match;
+	const struct sunxi_cpufreq_soc_data *soc_data;
 	int *opp_tokens;
 	char name[MAX_NAME_LEN];
 	unsigned int cpu;
-	u32 speed = 0;
+	u32 version = 0;
 	int ret;
 
 	match = dev_get_platdata(&pdev->dev);
 	if (!match)
 		return -EINVAL;
+	soc_data = match->data;
 
 	opp_tokens = kcalloc(num_possible_cpus(), sizeof(*opp_tokens),
 			     GFP_KERNEL);
 	if (!opp_tokens)
 		return -ENOMEM;
 
-	ret = sun50i_cpufreq_get_efuse(match-> data, &speed);
+	ret = sun50i_cpufreq_get_efuse(match->data, &version, name);
 	if (ret) {
 		kfree(opp_tokens);
 		return ret;
 	}
 
-	snprintf(name, MAX_NAME_LEN, "speed%d", speed);
-	pr_info("Using CPU speed bin %s\n", name);
-
 	for_each_possible_cpu(cpu) {
 		struct device *cpu_dev = get_cpu_device(cpu);
 
@@ -152,6 +196,16 @@ static int sun50i_cpufreq_nvmem_probe(struct platform_device *pdev)
 			pr_err("Failed to set prop name\n");
 			goto free_opp;
 		}
+
+		if (soc_data->ver_freq_limit) {
+			opp_tokens[cpu] = dev_pm_opp_set_supported_hw(cpu_dev,
+								  &version, 1);
+			if (opp_tokens[cpu] < 0) {
+				ret = opp_tokens[cpu];
+				pr_err("Failed to set hw\n");
+				goto free_opp;
+			}
+		}
 	}
 
 	cpufreq_dt_pdev = platform_device_register_simple("cpufreq-dt", -1,
@@ -165,8 +219,11 @@ static int sun50i_cpufreq_nvmem_probe(struct platform_device *pdev)
 	pr_err("Failed to register platform device\n");
 
 free_opp:
-	for_each_possible_cpu(cpu)
+	for_each_possible_cpu(cpu) {
 		dev_pm_opp_put_prop_name(opp_tokens[cpu]);
+		if (soc_data->ver_freq_limit)
+			dev_pm_opp_put_supported_hw(opp_tokens[cpu]);
+	}
 	kfree(opp_tokens);
 
 	return ret;
@@ -175,12 +232,22 @@ static int sun50i_cpufreq_nvmem_probe(struct platform_device *pdev)
 static void sun50i_cpufreq_nvmem_remove(struct platform_device *pdev)
 {
 	int *opp_tokens = platform_get_drvdata(pdev);
+	const struct of_device_id *match;
+	const struct sunxi_cpufreq_soc_data *soc_data;
 	unsigned int cpu;
 
+	match = dev_get_platdata(&pdev->dev);
+	if (!match)
+		return;
+	soc_data = match->data;
+
 	platform_device_unregister(cpufreq_dt_pdev);
 
-	for_each_possible_cpu(cpu)
+	for_each_possible_cpu(cpu) {
 		dev_pm_opp_put_prop_name(opp_tokens[cpu]);
+		if (soc_data->ver_freq_limit)
+			dev_pm_opp_put_supported_hw(opp_tokens[cpu]);
+	}
 
 	kfree(opp_tokens);
 }
@@ -195,6 +262,7 @@ static struct platform_driver sun50i_cpufreq_driver = {
 
 static const struct sunxi_cpufreq_soc_data sun50i_h616_data = {
     .efuse_xlate = sun50i_h616_efuse_xlate,
+	.ver_freq_limit = true,
 };
 
 static const struct sunxi_cpufreq_soc_data sun50i_h6_data = {
@@ -240,8 +308,8 @@ static int __init sun50i_cpufreq_init(void)
 		return ret;
 
 	sun50i_cpufreq_pdev =
-		platform_device_register_data(NULL,
-		"sun50i-cpufreq-nvmem", -1, match, sizeof(*match));
+		platform_device_register_data(NULL, "sun50i-cpufreq-nvmem", 
+						-1, match, sizeof(*match));
 	ret = PTR_ERR_OR_ZERO(sun50i_cpufreq_pdev);
 	if (ret == 0)
 		return 0;
-- 
2.34.1

